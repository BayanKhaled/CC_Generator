2017/9/25
●契約開始

●pythonでgenerator作り直したい
●Gradientまでカバーする仕様：
・ダイアグラムの表現：４つのamplitude＋１つの相互作用積分　←一緒
・ダイアグラムの評価：相互作用積分の順番も変わりうる　←ラムダ方程式
・密度行列の評価：相互作用積分のかわりにλ演算子が入る；相互作用積分IDでλ演算子のレベルを表現（符号反転）。λにTがぶら下がっていく形なので、Tの順番だけが問題：
	最終的な形（hole indexとparticle indexの数）から、λのどのindexがfixedなのかはわかる

・ダイアグラムを構成する５つ（最大）のテンソルを共通のデータ形式で表現することが必要
・テンソルの属性：
	基本は4-index
	一時的に最大6-indexになる必要あり
・ダイアグラムの導出、ソート、評価（コード生成）を別モジュールとする；データはテキストファイルで入出力
	導出・・・順番は気にせず、とにかく必要なダイアグラムを導出する
	ソート・・・導出されたダイアグラムを、演算量が最小になるように並び替え（ダイアグラム内、ダイアグラム間の両方）
	評価・・・ソードされたダイアグラムリストに基づき、コード生成；ここが一番キモ

・ダイアグラム保存の形式：
	L1：NDig
	L2:m11,m21,m31,m12,m22,m32,m13,m23,m33,m14,m24,m34,m5 W XXXXX　←従来の13要素整数＋位相付き重み＋種類（T, R, L, G)
	L3：・・・

・データ形式：
	ダイアグラム…メンバ変数として以下を持つ：
		テンソルのリスト（5個）
	Factorizeされたダイアグラム群…メンバ変数として以下を持つ：
		含まれるダイグラムのリスト
		レベル４からレベル1までの中間体テンソルおよびそれに必要な（和＋積）のリスト
		※000があったらレベルを繰り上げる（例：220 111 000 000 8 --> 220 111 8として、G8とT111のcontractionをレベル2とする）
		たとえば以下の4ダイアグラムが与えられた時：
			220 000 000 000 5
			220 111 000 000 8
			220 111 111 000 11
			220 222 000 000 11
			上記４ダイアグラムを1グループとしてインスタンス化
			レベル4：中間体なし
			レベル3：和積はG8 + G11*T111→中間体I3_1、G11→中間体I3_2
			レベル2：和積はG5 + I3_1*T111 + I3_2*T222→I2_1
			レベル1：和積はI2_1*T220→I1→最終結果に足し込み
	中間体…メンバ変数として以下を持つ：
		nA, nI, nC, nK
		含まれるテンソルシークエンスのリスト；係数も一緒に格納（←これだけで代数式が再現できるように）
		

・ダイアグラムの評価モジュール
	０．（ソートされた）ダイグラムを読み込んでインスタンス生成
	１．ダイアグラム群の生成
	２．コード生成
		各ダイグラム群ごとに、
			レベルＬのループ（Ｌ：４～１）
				レベルＬ＋１の中間体作成に必要なcontractionの一覧
				作成される中間体を定義


	

※等価な中間体を使いまわせるような仕組みが欲しい　→生成済みの中間体をsetに格納；新たな中間体が生じる都度、既存のものと一致すればそれを使う。既存になければ新規追加していく


・Stringループを単一ループで書いたら？
	ループ長が長い；8バイト整数で表現できる上限？
	Pのアドレス、Qのアドレス→R=PQのアドレスとパリティを求めることが必要
	関数化するとF(AddP,AddQ,nP,nQ)＝AddR（符号はパリティ、排他原理に抵触する場合は０を返す）
	Fのアルゴリズム：
		AddPとnPからStringPを作成　←Stringの総数と同じサイズの配列が必要、メモリ圧迫
		StringQについても同様
		P,Qを合成してRを作成。パリティも求める
		AddR求める



2017/11/26
● Githubで運用
・アドレス：https://github.com/yakinaga/CC_Generator.git
・作業場所：
	Mac：/Users/akinaga/Work/CC_Generator
	Win：/cygdrive/c/Users/akinaga/Documents/Projects/NTChem_CC_3/CC_Generator

2017/11/29
●メインプログラム等のフレームをだいたい整備
・ディクショナリ等を使うとかなり楽。

ToDo:
●Contraction関数
・rearrangeとcontractionから構成される
・contractionのタイプによって場合分け
・タイプ判別には、中間体の中身に関する情報が必要　→中間体をTensorインスタンスとして、typ変数にタイプを入れておく
・タイプはＩＴ，ＬＩＴ，ＬＴの3通り（基底状態のamplitude eq.は常にＩＴ）

2017/11/30
●Contratcion関数（続き）
・中間体のサイズ
・中間体のデータ形式（Ｔｅｎｓｏｒインスタンス？）
・テンソル（Ｃ，Ｋ，Ａ，Ｉ）はＣ×Ｋ配列をＡ，Ｉの組み合わせ毎に保存するようにする　　＜＝＝！！！
	rearrangeはＡ，Ｉの組み合わせ毎に行い、いったんファイルに保存する
	contractionで必要に応じてファイルから読み込む

2017/12/01
●Stringの使い方の参考：
・GAMESSのCEPAプログラム（cepa.src L2100付近、およびormas1.srcのresetdeルーチン）　←いまいち

●他のところを整備：
・Diagramクラスに重み計算関数を実装
・同じくパリティ計算関数：
	{pqrs}{aiai...}...{bjbj...}のように並べる（Hamiltonianが最初）
	それぞれの演算子位置をindexとして、次に向かう先のindexを要素としたリストを作る
	internal lineどうしのcontractionを取って、hole lineのダブりを無くす
	external lineどうしは、左から順番にparticleがholeにつながるようにする
	hole lineの数を保存
	リストから閉経路を作る。一つ作るごとにループ数を＋１するとともに、ループに含まれる要素をリストから削除する。リストサイズが０になるまで続ける。
		ただしholeとparticleが同数でないと破たんする・・・
	基底状態、Jacobian右対角化は上記でOKのはず；λ方程式はまた別	→一般性を持たせるために、射影先の励起（もしくは脱励起）演算子も入れといた方がよいか

●やっぱり重みとパリティは別のモジュールの方がいいかも（パリティ計算の分岐が増えてややこしくなる）

